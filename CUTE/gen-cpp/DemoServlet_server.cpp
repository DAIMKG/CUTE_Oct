// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "DemoServlet.h"
#include <thrift/protocol/TJSONProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/THttpServer.h>
#include <queue>
#include <unordered_map>
#include "include/utils.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::demo;


const char *ENTITYDATA = "/Users/serena/Desktop/daim/demo/data/entity.txt";
const char *TPYECOUNTDATA = "/Users/serena/Desktop/daim/demo/data/typeCount.txt";
const char *EDGECOUNT = "/Users/serena/Desktop/daim/demo/data/w.tsv";

const int MAXENTITY = 2700000;
const int MAXTHREAD = 100;
const int MAXENTITYLEN = 1000;
const int MAXCANDIDATENUM = 5;

#define min(x, y) (((x) < (y)) ? (x) : (y))
#define max(x, y) (((x) < (y)) ? (y) : (x))


char *entity[MAXENTITY];
int totEntity, entityLen[MAXENTITY];

std::unordered_map<std::string, int> typeCount;

/*
int totTriple;
std::unordered_map<std::string, int> numberOfp, numberOfEntity, numberOfpo, numberOfsp;
*/

struct Input {
    int n, m;
    std::vector<std::vector<std::string> > input;
};

/* ------------------------------------------------------------------------------ */

/* Data structure for graph */
std::unordered_map<std::string, int> entityID;

struct L {
    bool edgedir; // 0 for original; 1 for reverse
    int to;
    double edgew;
    std::string edgeP;
    L(){}
    L(bool edgedir_, int to_, double edgew_, std::string edgeP_):
    edgedir(edgedir_), to(to_), edgew(edgew_), edgeP(edgeP_){}
};

std::vector<L> head[MAXENTITY];


int dis[MAXENTITY];
double disW[MAXENTITY];


int que[MAXENTITY];
int fromNode[MAXENTITY];
std::vector<L>::iterator fromEdge[MAXENTITY];

/* ------------------------------------------------------------------------------ */


/* Thread data structure for disambiguation */
struct DisambiguationThread{
    char *str;
};


/* Data structure for recording entity in disambiguation */
struct R {
    int id;
    double w;
    R(int id_, double w_):id(id_), w(w_){}
    inline bool operator < (const R &x) const {
        return w > x.w;
    }
};


/* Thread function for disambiguation */
void *workForDisambiguation(void *threadarg) {

    /* Data structure for disambiguation */
    std::priority_queue<R> candidate;

    struct DisambiguationThread *my_data;
    my_data = (struct DisambiguationThread *)threadarg;

    const char *s1 = my_data -> str;

    int l1 = strlen(s1);
    bool match1[MAXENTITYLEN], match2[MAXENTITYLEN];

    for (int x = 0; x < totEntity; x++) {
        const char *s2 = entity[x];
        int l2 = entityLen[x];
        memset(match1, 0, sizeof(bool) * l1);
        memset(match2, 0, sizeof(bool) * l2);

        int r = max(l1, l2) / 2 - 1, p = 0, m = 0, t = 0;
        for (int i = 0; i < min(l1, l2) && p < 4; i++)
            if(s1[i] == s2[i]
            || (s1[i] >= 'a' && s1[i] <= 'z' && s2[i] >= 'A' && s2[i] <= 'Z' && s1[i] - 'a' + 'A' == s2[i])
            || (s1[i] >= 'A' && s1[i] <= 'Z' && s2[i] >= 'a' && s2[i] <= 'z' && s1[i] - 'A' + 'a' == s2[i])
            || (s1[i] == ' ' && s2[i] == '_')) p++;
            else break;
        m = p;
        for (int i = p; i < l1; i++)
            for (int j = max(p, i - r); j <= min(l2 - 1, i + r); j++)
                if (!match2[j] && (s1[i] == s2[j]
                                || (s1[i] >= 'a' && s1[i] <= 'z' && s2[j] >= 'A' && s2[j] <= 'Z' && s1[i] - 'a' + 'A' == s2[j])
                                || (s1[i] >= 'A' && s1[i] <= 'Z' && s2[j] >= 'a' && s2[j] <= 'z' && s1[i] - 'A' + 'a' == s2[j])
                                || (s1[i] == ' ' && s2[j] == '_'))) {
                    match1[i] = match2[j] = 1;
                    m++;
                    break;
                }
        double w;
        if (m == 0) w = 0;
        else {
            for(int i = p, j = p; i < l1; i++)
                if(match1[i]) {
                    while(j < l2 && !(s1[i] == s2[j]
                                    || (s1[i] >= 'a' && s1[i] <= 'z' && s2[j] >= 'A' && s2[j] <= 'Z' && s1[i] - 'a' + 'A' == s2[j])
                                    || (s1[i] >= 'A' && s1[i] <= 'Z' && s2[j] >= 'a' && s2[j] <= 'z' && s1[i] - 'A' + 'a' == s2[j])
                                    || (s1[i] == ' ' && s2[j] == '_')))
                        j++;
                    if(j < l2 && !(s1[i] == s2[j]
                                || (s1[i] >= 'a' && s1[i] <= 'z' && s2[j] >= 'A' && s2[j] <= 'Z' && s1[i] - 'a' + 'A' == s2[j])
                                || (s1[i] >= 'A' && s1[i] <= 'Z' && s2[j] >= 'a' && s2[j] <= 'z' && s1[i] - 'A' + 'a' == s2[j])
                                || (s1[i] == ' ' && s2[j] == '_')))
                        t++;
                    j++;
                }

            t >>= 1;
            double ret = (1.0 * m / l1 + 1.0 * m / l2 + 1.0 * (m - t) / m) / 3;
            w = ret + p * 0.1 * (1 - ret);
        }

        if (candidate.size() < MAXCANDIDATENUM) candidate.push(R(x, w));
        else {
            if (candidate.top().w < w) {
                candidate.pop();
                candidate.push(R(x, w));
            }
        }
    }

    int *result = new int[MAXCANDIDATENUM];
    for (int i = 0; i < MAXCANDIDATENUM; i++) {
        result[i] = candidate.top().id;
        candidate.pop();
    }

    pthread_exit(result);

}

/* ------------------------------------------------------------------------------ */


/* Data structure for finding common types */
struct OutputForCommonTypes {
    ReturnedCommonTypes _return;
};

inline bool typesCmp(OneType x, OneType y) {
    return typeCount[x.typeName] > typeCount[y.typeName];
}

/* Thread function for finding common types */
void *workForCommonTypes(void *threadarg) {
    struct Input *my_data = (struct Input *)threadarg;
    std::vector<std::vector<std::string> > & input = my_data -> input;
    int n = my_data -> n;
    int m = my_data -> m;

    OutputForCommonTypes *output = new OutputForCommonTypes;
    std::string sparql;
    HttpGet http;

    for (int j = 0; j < m; j++) {
        std::vector<std::vector<std::string> > res;
        Types result;
        int tot;

        sparql = "SELECT ?type WHERE {\n";

        for (int i = 0; i < n; i++) {
            sparql += "    <http://yago-knowledge.org/resource/" + input[i][j] + ">";
            sparql += " <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>";
            sparql += " ?type .\n";
        }
        sparql += "FILTER (\n";
        sparql += "    STR(?type) != \"http://www.w3.org/2002/07/owl#Thing\"\n";
        sparql += ")\n";
        sparql += "}\n";

        std::cerr << sparql;

        http.httpsend(res, sparql);
        tot = res.size();

        for (int i = 0; i < tot; i++) {
            OneType t;
            if (http.parseURI(t.typeName, res[i][0]))
                result.types.push_back(t);
        }

        sort(result.types.begin(), result.types.end(), typesCmp);

        (output -> _return).push_back(result);

    }

    pthread_exit(output);
}

/* ------------------------------------------------------------------------------ */

/* Data structure for finding common facts */
struct OutputForCommonFacts {
    ReturnedCommonFacts _return;
};

/*
inline bool factsCmp(OneFact x, OneFact y) {
    double wx, wy;

    if (numberOfEntity.find(x.SorO) == numberOfEntity.end()) wx = 0;
    else {
        if (x.direction == 0)
            wx = 1.0 * numberOfpo[x.P + x.SorO] / numberOfEntity[x.SorO] * log(totTriple / numberOfp[x.P]);
        else
            wx = 1.0 * numberOfsp[x.SorO + x.P] / numberOfEntity[x.SorO] * log(totTriple / numberOfp[x.P]);
    }

    if (numberOfEntity.find(y.SorO) == numberOfEntity.end()) wy = 0;
    else {
        if (y.direction == 0)
            wy = 1.0 * numberOfpo[y.P + y.SorO] / numberOfEntity[y.SorO] * log(totTriple / numberOfp[y.P]);
        else
            wy = 1.0 * numberOfsp[y.SorO + y.P] / numberOfEntity[y.SorO] * log(totTriple / numberOfp[y.P]);
    }

    return wx > wy;

}
*/

/* Thread function for finding common facts */
void *workForCommonFacts(void *threadarg) {
    struct Input *my_data = (struct Input *)threadarg;
    std::vector<std::vector<std::string> > & input = my_data -> input;
    int n = my_data -> n;
    int m = my_data -> m;

    OutputForCommonFacts *output = new OutputForCommonFacts;
    std::string sparql;

    HttpGet http;

    for (int j = 0; j < m; j++) {
        std::vector<std::vector<std::string> > res;

        int tot;
        Facts result;
        

        sparql = "SELECT ?p ?o {\n";

        for (int i = 0; i < n; i++) {
            sparql += "    <http://yago-knowledge.org/resource/" + input[i][j] + ">";
            sparql += " ?p";
            sparql += " ?o .\n";
        }
        sparql += "FILTER (\n";
        sparql += "    STR(?p) != \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"\n";
        sparql += "&&  STR(?p) != \"http://yago-knowledge.org/resource/hasWikipediaAnchorText\"\n";
        sparql += "&&  STR(?p) != \"http://www.w3.org/2000/01/rdf-schema#label\"\n";
        sparql += "&&  STR(?p) != \"http://yago-knowledge.org/resource/redirectedFrom\"\n";
        sparql += "&&  STR(?p) != \"http://yago-knowledge.org/resource/linksTo\"\n";
        sparql += ")\n";
        sparql += "}\n";
        std::cerr << sparql;

        http.httpsend(res, sparql);

        tot = res.size();

        for (int i = 0; i < tot; i++) {
            OneFact t;
            t.direction = 0;
            http.parseURI(t.P, res[i][0]);
            if (http.parseURI(t.SorO, res[i][1]))
                result.facts.push_back(t);
        }


        /* -------------------------------------------- */

        
        sparql = "SELECT ?s ?p {\n";

        for (int i = 0; i < n; i++) {
            sparql += "    ?s";
            sparql += " ?p";
            sparql += " <http://yago-knowledge.org/resource/" + input[i][j] + "> .\n";
        }
        sparql += "FILTER (\n";
        sparql += "    STR(?p) != \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"\n";
        sparql += "&&  STR(?p) != \"http://yago-knowledge.org/resource/hasWikipediaAnchorText\"\n";
        sparql += "&&  STR(?p) != \"http://www.w3.org/2000/01/rdf-schema#label\"\n";
        sparql += "&&  STR(?p) != \"http://yago-knowledge.org/resource/redirectedFrom\"\n";
        sparql += "&&  STR(?p) != \"http://yago-knowledge.org/resource/linksTo\"\n";
        sparql += ")\n";
        sparql += "}\n";

        std::cerr << sparql;

        res.clear();

        http.httpsend(res, sparql);
        tot = res.size();

        for (int i = 0; i < tot; i++) {
            OneFact t;
            t.direction = 1;
            http.parseURI(t.P, res[i][1]);
            if (http.parseURI(t.SorO, res[i][0]))
                result.facts.push_back(t);
        }

        //sort(result.begin(), result.end(), factsCmp);

        (output -> _return).push_back(result);

    }

    pthread_exit(output);

}

/* ------------------------------------------------------------------------------ */

/* Data structure for finding common pattern */
struct OutputForCommonPattern {
    ReturnedCommonPattern _return;
};

const int MAXL = 0x3fffffff;

bool Edge::operator < (demo::Edge const &t) const {
    return s + p + o < t.s + t.p + t.o;
}

void bfs(std::vector<Edge> & pattern, int S, int T) {
    int h, t;

    dis[S] = 0;
    disW[S] = 0;
    que[h = t = 1] = S;

    std::vector<L>::iterator it;
    while (h <= t) {
        int sta = que[h++];
        if (sta == T) break;
        for (it = head[sta].begin(); it != head[sta].end(); it++)
            if (dis[it -> to] == MAXL || (dis[it -> to] == dis[sta] + 1 && disW[it -> to] < disW[sta] + it -> edgew)) {
                dis[it -> to] = dis[sta] + 1;
                disW[it -> to] = disW[sta] + it -> edgew;
                fromNode[it -> to] = sta;
                fromEdge[it -> to] = it;
                que[++t] = it -> to;
            }
    }

    for (int i = 1; i <= t; i++)
        dis[que[i]] = MAXL;

    for (int i = T; i != S; i = fromNode[i]) {
        it = fromEdge[i];
        Edge edge;
        edge.p = it -> edgeP;
        if (it -> edgedir == 0) {
            edge.s = entity[fromNode[i]];
            edge.o = entity[i];
        }
        else {
            edge.s = entity[i];
            edge.o = entity[fromNode[i]];
        }
        pattern.push_back(edge);
    }

}


void buildPattern(std::vector< std::vector<Edge> > & pattern, const std::vector<std::string> & inputRow) {
    int m = inputRow.size();

    for (int i = 0; i < m; i++)
        for (int j = i + 1; j < m; j++) {

            // Edges represent a path between a pair of nodes "in order"
            std::vector<Edge> edges;

            printf("%s %s\n", entity[entityID[inputRow[i]]], entity[entityID[inputRow[j]]]);
            bfs(edges, entityID[inputRow[i]], entityID[inputRow[j]]);
            pattern.push_back(edges);
        }
}

void findCommonPattern(
ReturnedCommonPattern & _return,
const std::vector< std::vector< std::vector<Edge> > > & patterns,
const std::vector< std::vector< std::string> > & input) {

    int n = input.size(), m;
    if (n == 0) return;
    m = input[0].size();


    int pairPoint = 0;

    for (int x = 0; x < m; x++)
        for (int y = x + 1; y < m; y++) {

            // init commonEdges from the first pattern
            std::vector<Edge> commonEdges;
            std::vector<Edge>::iterator it;

            std::vector<Edge> curEdges = patterns[0][pairPoint];
            for (int i = 0; i < curEdges.size(); i++) {

                int t = 0;
                Edge e = curEdges[i];

                if (e.s == input[0][x]) e.s = "?v" + std::to_string(x);
                else if (e.s == input[0][y]) e.s = "?v" + std::to_string(y);
                else {
                    bool flag = true;
                    for (int z = 0; z < m; z++)
                        if (e.s == input[0][z]) {
                            flag = false;
                            break;
                        }
                    if (flag) {
                        e.s = "?t" + std::to_string(x) + "_" + std::to_string(y) + "_" + std::to_string(t);
                        t++;
                    }
                }

                if (e.o == input[0][x]) e.o = "?v" + std::to_string(x);
                else if (e.o == input[0][y]) e.o = "?v" + std::to_string(y);
                else {
                    bool flag = true;
                    for (int z = 0; z < m; z++)
                        if (e.o == input[0][z]) {
                            flag = false;
                            break;
                        }
                    if (flag) {
                        e.o = "?t" + std::to_string(x) + "_" + std::to_string(y) + "_" + std::to_string(t);
                        t++;
                    }
                }

                commonEdges.push_back(e);
            }


            sort(commonEdges.begin(), commonEdges.end());
            for (it = commonEdges.begin(); it != commonEdges.end(); it++) {
                std::cerr << it -> s << " " << it -> p << " " << it -> o << std::endl;
            }
            std::cerr << std::endl;

            // Intersection !!!
            for (int c = 1; c < n; c++) {

                std::vector<Edge> curEdges = patterns[c][pairPoint];

                std::vector<Edge> tmpEdges;

                for (int i = 0; i < curEdges.size(); i++) {

                    int t = 0;
                    Edge e = curEdges[i];

                    if (e.s == input[c][x]) e.s = "?v" + std::to_string(x);
                    else if (e.s == input[c][y]) e.s = "?v" + std::to_string(y);
                    else {
                        bool flag = true;
                        for (int z = 0; z < m; z++)
                            if (e.s == input[c][z]) {
                                flag = false;
                                break;
                            }
                        if (flag) {
                            e.s = "?t" + std::to_string(x) + "_" + std::to_string(y) + "_" + std::to_string(t);
                            t++;
                        }
                    }

                    if (e.o == input[c][x]) e.o = "?v" + std::to_string(x);
                    else if (e.o == input[c][y]) e.o = "?v" + std::to_string(y);
                    else {
                        bool flag = true;
                        for (int z = 0; z < m; z++)
                            if (e.o == input[c][z]) {
                                flag = false;
                                break;
                            }
                        if (flag) {
                            e.o = "?t" + std::to_string(x) + "_" + std::to_string(y) + "_" + std::to_string(t);
                            t++;
                        }
                    }

                    tmpEdges.push_back(e);

                }

                sort(tmpEdges.begin(), tmpEdges.end());

                for (it = tmpEdges.begin(); it != tmpEdges.end(); it++) {
                    std::cerr << it -> s << " " << it -> p << " " << it -> o << std::endl;
                }
                std::cerr << std::endl;

                it = set_intersection(commonEdges.begin(), commonEdges.end(), tmpEdges.begin(), tmpEdges.end(), commonEdges.begin());

                commonEdges.resize(it - commonEdges.begin());
            }

            for (it = commonEdges.begin(); it != commonEdges.end(); it++) {
                std::cerr << it -> s << " " << it -> p << " " << it -> o << std::endl;
                _return.push_back(*it);
            }

            pairPoint++;

        }

}

/* Thread function for finding common facts */
void *workForCommonPattern(void *threadarg) {
    struct Input *my_data = (struct Input *)threadarg;
    std::vector<std::vector<std::string> > & input = my_data -> input;
    int n = my_data -> n;
    int m = my_data -> m;

    std::vector< std::vector< std::vector<Edge> > > patterns;

    for (int i = 0; i < n; i++) {

        // One pattern contains serveral std::vector<Edge> that represent a path between a pair of nodes.
        std::vector< std::vector<Edge> > pattern;

        buildPattern(pattern, input[i]);
        patterns.push_back(pattern);
    }

    OutputForCommonPattern *output = new OutputForCommonPattern;

    findCommonPattern(output -> _return, patterns, input);


    pthread_exit(output);
}


/* ------------------------------------------------------------------------------ */

class DemoServletHandler : virtual public DemoServletIf {
public:
    DemoServletHandler() {
        printf("Begin initialization.\n");

        printf("reading entity...\n");
        readEntity();
        printf("End.\n\n");

        printf("reading type count...\n");
        readTypeCount();
        printf("End.\n\n");

        //printf("reading edge count...\n");
        //readEdgeCount();
        //printf("End.\n\n");

        printf("building graph...\n");
        buildGraph();
        printf("End.\n\n");

        printf("Initialization done.\n");
    }

    inline void identify(int& n, int& m, const std::vector<std::vector<std::string> > & input) {
        n = input.size();
        if (n == 0) {
            printf("[Error] no colume?\n");
            m = -1;
            return;
        }
        m = input[0].size();
    }

    /*
    void readEntity() {
        //Read All entity from external txt file
        int fd = open(ENTITYDATA, O_RDONLY);
        struct stat stat;
        fstat(fd, &stat);
        int tot_len = stat.st_size, cur_len = 0;

        // Use mmap to enhance the performance
        char *bufp = (char *)mmap(NULL, tot_len, PROT_READ, MAP_SHARED, fd, 0);
        for (int i = 0; i < tot_len; i++) {
            if (*(bufp + i) == '\n') {
                entityLen[totEntity] = cur_len;
                entity[totEntity++] = bufp + i - cur_len;
                cur_len = 0;
            }
            else {
                cur_len++;
            }
        }
        entityLen[totEntity] = cur_len;
        entity[totEntity++] = bufp + tot_len - cur_len;
    
        close(fd);
    }
    */


    void readEntity() {

        FILE *fp = fopen(ENTITYDATA, "r");

        char tmp[MAXENTITYLEN];
        while (~fscanf(fp, "%s", tmp)) {
            int len = strlen(tmp);

            entityLen[totEntity] = len - 2;
            entity[totEntity] = new char [len + 10];
            for (int i = 1; i < len - 1; i++)
                entity[totEntity][i - 1] = tmp[i];
            entity[totEntity][len - 1] = '\0';
            entityID[entity[totEntity]] = totEntity;
            totEntity++;
        }
        fclose(fp);
    }

    void readTypeCount() {
        FILE *fp = fopen(TPYECOUNTDATA, "r");

        char tmp[MAXENTITYLEN];
        int x;
        while (~fscanf(fp, "%s%d", tmp, &x)) {
            int len = strlen(tmp);
            char *t = new char [len + 10];
            for (int i = 1; i < len - 1; i++)
                t[i - 1] = tmp[i];
            typeCount[t] = x;
        }

        fclose(fp);
    }

    /*
    void readEdgeCount() {
        FILE *fp = fopen(EDGECOUNT, "r");

        char s[MAXENTITYLEN], p[MAXENTITYLEN], o[MAXENTITYLEN];
        totTriple = 0;
        while (~fscanf(fp, "%s%s%s%*lf", s, p, o)) {
            totTriple++;
            std::string tmps = s, tmpp = p, tmpo = o;
            tmps = tmps.substr(1, tmps.length() - 2);
            tmpp = tmpp.substr(1, tmpp.length() - 2);
            tmpo = tmpo.substr(1, tmpo.length() - 2);

            numberOfEntity[tmps]++;
            numberOfEntity[tmpo]++;
            numberOfp[tmpp]++;
            numberOfpo[tmpp + tmpo]++;
            numberOfsp[tmps + tmpp]++;
        }
    }
    */

    inline void add(int x, int y, std::string p, double w, bool dir) {
        head[x].push_back(L(dir, y, w, p.substr(1, p.length() - 2)));
    }

    void buildGraph() {

        FILE *fp = fopen(EDGECOUNT, "r");
        char s[MAXENTITYLEN], p[MAXENTITYLEN], o[MAXENTITYLEN];
        double w;
        for (int i = 0; i < totEntity; i++)
            dis[i] = MAXL;
        while (~fscanf(fp, "%s%s%s%lf", s, p, o, &w)) {
            std::string tmp = s;
            int x, y;
            tmp = tmp.substr(1, tmp.length() - 2);
            x = entityID[tmp];


            tmp = o;
            tmp = tmp.substr(1, tmp.length() - 2);
            y = entityID[tmp];

            add(x, y, p, w, 0);
            add(y, x, p ,w, 1);
        }
    }


    void disambiguation(std::vector<OneRowCandidate> & _return, const std::vector<std::vector<std::string> > & rawInput) {

        printf("Begin disambiguation. %d\n", totEntity);


        /* The number of row and column in user's input */
        int n, m;

        identify(n, m, rawInput);
        if (m == -1) return;

        /* Thread pool */
        pthread_t tids[MAXTHREAD];

        struct DisambiguationThread td[MAXTHREAD];


        
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++) {
                int cur = i * m + j;
                td[cur].str = (char *)malloc(MAXENTITYLEN * sizeof(char));
                strcpy(td[cur].str, rawInput[i][j].c_str());

                pthread_create(&tids[cur], NULL, workForDisambiguation, (void *)&td[cur]);
            }

        // result records the serial number of final results of the candidate entities
        int *result;
        
        for (int i = 0; i < n; i++) {
            OneRowCandidate tmp;
            for (int j = 0; j < m; j++) {
                Candidate tmps;
                pthread_join(tids[i * m + j], (void **)&result);
                for (int k = MAXCANDIDATENUM - 1; k >= 0; k--) {
                    std::string ss = "";
                    for (int l = 0; l < entityLen[result[k]]; l++)
                        ss += entity[result[k]][l];
                    tmps.c.push_back(ss);
                }
                tmp.row.push_back(tmps);
            }
            _return.push_back(tmp);
        }
        

        printf("Disambiguation done.\n");

        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++) {
                for (int k = 0; k < 5; k++)
                    std::cerr << _return[i].row[j].c[k] << std::endl;
                std::cerr << std::endl;
            }
    }

    void findCommonInfo(CommonInfo& _return, const std::vector<std::vector<std::string> > & input, const bool requirePattern) {
        printf("Begin findCommonInfo.\n");

        /* The number of row and column in user's input */
        int n, m;
        identify(n, m, input);
        if (m == -1) return;
        

        struct Input td;
        td.input = input;
        td.n = n;
        td.m = m;


        /* Thread pool */
        pthread_t tids[3];

        /* findCommonTypes thread */
        pthread_create(&tids[0], NULL, workForCommonTypes, (void *)&td);


        /* findCommonFacts thread */
        pthread_create(&tids[1], NULL, workForCommonFacts, (void *)&td);

        if (requirePattern)
            /* findCommonPattern thread */
            pthread_create(&tids[2], NULL, workForCommonPattern, (void *)&td);


        /* findCommonTypes thread output */
        OutputForCommonTypes *outputForCommonTypes;
        pthread_join(tids[0], (void **)&outputForCommonTypes);
        _return.t = outputForCommonTypes -> _return;

        /* findCommonFacts thread output */
        OutputForCommonFacts *outputForCommonFacts;
        pthread_join(tids[1], (void **)&outputForCommonFacts);
        _return.f = outputForCommonFacts -> _return;


        if (requirePattern) {
            /* findCommonPattern thread output */
            OutputForCommonPattern *outputForCommonPattern;
            pthread_join(tids[2], (void **)&outputForCommonPattern);
            _return.p = outputForCommonPattern -> _return;
        }

        printf("findCommonInfo done.\n");
    }

    void query(SparqlAndResult& _return, const CommonInfo& info, const std::vector<std::vector<std::string> > & input) {

        int n, m;
        identify(n, m, input);
        std::string sparql = "SELECT ";

        for (int i = 0; i < m; i++)
            sparql += "?v" + std::to_string(i) + " ";

        sparql += "WHERE {\n";

        ReturnedCommonPattern pattern = info.p;

        for (int i = 0; i < pattern.size(); i++) {
            if (pattern[i].s[0] == '?') sparql += "    " + pattern[i].s;
            else sparql += "    <http://yago-knowledge.org/resource/" + pattern[i].s + ">";

            sparql += " <http://yago-knowledge.org/resource/" + pattern[i].p + ">";

            if (pattern[i].o[0] == '?') sparql += " " + pattern[i].o + " .\n";
            else sparql += " <http://yago-knowledge.org/resource/" + pattern[i].o + "> .\n";
        }

        sparql += "\n";

        ReturnedCommonTypes ts = info.t;
        for (int i = 0; i < ts.size(); i++) {
            for (int j = 0; j < ts[i].types.size(); j++) {
                sparql += "    ?v" + std::to_string(i);
                sparql += " <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>";
                sparql += " <http://yago-knowledge.org/resource/" + ts[i].types[j].typeName + "> .\n";
            }
        }

        sparql += "\n";

        ReturnedCommonFacts fs = info.f;

        for (int i = 0; i < fs.size(); i++)
            for (int j = 0; j < fs[i].facts.size(); j++)
                if (fs[i].facts[j].direction == 0) {
                    sparql += "    ?v" + std::to_string(i);
                    sparql += " <http://yago-knowledge.org/resource/" + fs[i].facts[j].P + ">";
                    sparql += " <http://yago-knowledge.org/resource/" + fs[i].facts[j].SorO + "> .\n";
                }
                else {
                    sparql += "    <http://yago-knowledge.org/resource/" + fs[i].facts[j].SorO + ">";
                    sparql += " <http://yago-knowledge.org/resource/" + fs[i].facts[j].P + ">";
                    sparql += " ?v" + std::to_string(i) + " .\n";
                }

        sparql += "\n";

        sparql += "}\n";

        std::cerr << sparql;
        _return.sparql = sparql;

        HttpGet http;

        std::vector<std::vector<std::string> > res;
        http.httpsend(res, sparql);

        for (int i = 0; i < res.size(); i++) {
            bool flag = 1;
            Row r;
            for (int j = 0; j < res[i].size(); j++) {
                std::string tmp;
                flag &= http.parseURI(tmp, res[i][j]);
                r.row.push_back(tmp);
            }
            if (flag)
                _return.result.push_back(r);
        }
    }

    void queryWithNeg(SparqlAndResult& _return, const NegCommonInfo& negInfo, const std::string& sparql) {
        _return.sparql = sparql.substr(0, sparql.length() - 2);

        if (negInfo.hasProperty) {
            _return.sparql += "FILTER NOT EXISTS {\n";

            ReturnedCommonTypes ts = negInfo.t;
            for (int i = 0; i < ts.size(); i++) {
                for (int j = 0; j < ts[i].types.size(); j++) {
                    _return.sparql += "    ?v" + std::to_string(i);
                    _return.sparql += " <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>";
                    _return.sparql += " <http://yago-knowledge.org/resource/" + ts[i].types[j].typeName + "> .\n";
                }
            }

            _return.sparql += "\n";

            ReturnedCommonFacts fs = negInfo.f;

            for (int i = 0; i < fs.size(); i++)
                for (int j = 0; j < fs[i].facts.size(); j++)
                    if (fs[i].facts[j].direction == 0) {
                        _return.sparql += "    ?v" + std::to_string(i);
                        _return.sparql += " <http://yago-knowledge.org/resource/" + fs[i].facts[j].P + ">";
                        _return.sparql += " <http://yago-knowledge.org/resource/" + fs[i].facts[j].SorO + "> .\n";
                    }
                    else {
                        _return.sparql += "    <http://yago-knowledge.org/resource/" + fs[i].facts[j].SorO + ">";
                        _return.sparql += " <http://yago-knowledge.org/resource/" + fs[i].facts[j].P + ">";
                        _return.sparql += " ?v" + std::to_string(i) + " .\n";
                    }

            _return.sparql += "\n";
            _return.sparql += "}\n";
            _return.sparql += "\n";
        }

        if (negInfo.hasKeywords) {
            _return.sparql += "FILTER (\n";

            ReturnedCommonKeywords ks = negInfo.k;
            bool first = true;
            for (int i = 0; i < ks.size(); i++) {
                for (int j = 0; j < ks[i].keywords.size(); j++) {
                    if (first)
                        _return.sparql += "    STR(?v" + std::to_string(i) + ") != \"http://yago-knowledge.org/resource/" + ks[i].keywords[j] + "\"\n";
                    else
                        _return.sparql += "&&  STR(?v" + std::to_string(i) + ") != \"http://yago-knowledge.org/resource/" + ks[i].keywords[j] + "\"\n";
                    first = false;
                }
            }
            _return.sparql += ")\n";
            _return.sparql += "\n";
        }

        _return.sparql += "}\n";


        std::cerr << _return.sparql;

        HttpGet http;

        std::vector<std::vector<std::string> > res;
        http.httpsend(res, _return.sparql);

        for (int i = 0; i < res.size(); i++) {
            bool flag = 1;
            Row r;
            for (int j = 0; j < res[i].size(); j++) {
                std::string tmp;
                flag &= http.parseURI(tmp, res[i][j]);
                r.row.push_back(tmp);
            }
            if (flag)
                _return.result.push_back(r);
        }
    }
};


int main(int argc, char **argv) {

    int port = 9090;
    shared_ptr<DemoServletHandler> handler(new DemoServletHandler());
    shared_ptr<TProcessor> processor(new DemoServletProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new THttpServerTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TJSONProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();
    return 0;
}

