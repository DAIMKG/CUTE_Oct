/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "server_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace demo {


Candidate::~Candidate() throw() {
}


void Candidate::__set_c(const std::vector<std::string> & val) {
  this->c = val;
}

uint32_t Candidate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_c = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->c.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->c.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->c[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_c)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Candidate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Candidate");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->c.size()));
    std::vector<std::string> ::const_iterator _iter5;
    for (_iter5 = this->c.begin(); _iter5 != this->c.end(); ++_iter5)
    {
      xfer += oprot->writeString((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Candidate &a, Candidate &b) {
  using ::std::swap;
  swap(a.c, b.c);
}

Candidate::Candidate(const Candidate& other6) {
  c = other6.c;
}
Candidate& Candidate::operator=(const Candidate& other7) {
  c = other7.c;
  return *this;
}
void Candidate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Candidate(";
  out << "c=" << to_string(c);
  out << ")";
}


OneRowCandidate::~OneRowCandidate() throw() {
}


void OneRowCandidate::__set_row(const std::vector<Candidate> & val) {
  this->row = val;
}

uint32_t OneRowCandidate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->row.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->row[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OneRowCandidate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OneRowCandidate");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row.size()));
    std::vector<Candidate> ::const_iterator _iter13;
    for (_iter13 = this->row.begin(); _iter13 != this->row.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OneRowCandidate &a, OneRowCandidate &b) {
  using ::std::swap;
  swap(a.row, b.row);
}

OneRowCandidate::OneRowCandidate(const OneRowCandidate& other14) {
  row = other14.row;
}
OneRowCandidate& OneRowCandidate::operator=(const OneRowCandidate& other15) {
  row = other15.row;
  return *this;
}
void OneRowCandidate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OneRowCandidate(";
  out << "row=" << to_string(row);
  out << ")";
}


OneType::~OneType() throw() {
}


void OneType::__set_typeName(const std::string& val) {
  this->typeName = val;
}

uint32_t OneType::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_typeName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->typeName);
          isset_typeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_typeName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OneType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OneType");

  xfer += oprot->writeFieldBegin("typeName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->typeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OneType &a, OneType &b) {
  using ::std::swap;
  swap(a.typeName, b.typeName);
}

OneType::OneType(const OneType& other16) {
  typeName = other16.typeName;
}
OneType& OneType::operator=(const OneType& other17) {
  typeName = other17.typeName;
  return *this;
}
void OneType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OneType(";
  out << "typeName=" << to_string(typeName);
  out << ")";
}


Types::~Types() throw() {
}


void Types::__set_types(const std::vector<OneType> & val) {
  this->types = val;
}

uint32_t Types::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_types = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->types.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += this->types[_i22].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Types::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Types");

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->types.size()));
    std::vector<OneType> ::const_iterator _iter23;
    for (_iter23 = this->types.begin(); _iter23 != this->types.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Types &a, Types &b) {
  using ::std::swap;
  swap(a.types, b.types);
}

Types::Types(const Types& other24) {
  types = other24.types;
}
Types& Types::operator=(const Types& other25) {
  types = other25.types;
  return *this;
}
void Types::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Types(";
  out << "types=" << to_string(types);
  out << ")";
}


OneFact::~OneFact() throw() {
}


void OneFact::__set_direction(const bool val) {
  this->direction = val;
}

void OneFact::__set_P(const std::string& val) {
  this->P = val;
}

void OneFact::__set_SorO(const std::string& val) {
  this->SorO = val;
}

uint32_t OneFact::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_direction = false;
  bool isset_P = false;
  bool isset_SorO = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->direction);
          isset_direction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->P);
          isset_P = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->SorO);
          isset_SorO = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_direction)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_P)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_SorO)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OneFact::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OneFact");

  xfer += oprot->writeFieldBegin("direction", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->direction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("P", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->P);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("SorO", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->SorO);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OneFact &a, OneFact &b) {
  using ::std::swap;
  swap(a.direction, b.direction);
  swap(a.P, b.P);
  swap(a.SorO, b.SorO);
}

OneFact::OneFact(const OneFact& other26) {
  direction = other26.direction;
  P = other26.P;
  SorO = other26.SorO;
}
OneFact& OneFact::operator=(const OneFact& other27) {
  direction = other27.direction;
  P = other27.P;
  SorO = other27.SorO;
  return *this;
}
void OneFact::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OneFact(";
  out << "direction=" << to_string(direction);
  out << ", " << "P=" << to_string(P);
  out << ", " << "SorO=" << to_string(SorO);
  out << ")";
}


Facts::~Facts() throw() {
}


void Facts::__set_facts(const std::vector<OneFact> & val) {
  this->facts = val;
}

uint32_t Facts::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_facts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->facts.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->facts.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += this->facts[_i32].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_facts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_facts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Facts::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Facts");

  xfer += oprot->writeFieldBegin("facts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->facts.size()));
    std::vector<OneFact> ::const_iterator _iter33;
    for (_iter33 = this->facts.begin(); _iter33 != this->facts.end(); ++_iter33)
    {
      xfer += (*_iter33).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Facts &a, Facts &b) {
  using ::std::swap;
  swap(a.facts, b.facts);
}

Facts::Facts(const Facts& other34) {
  facts = other34.facts;
}
Facts& Facts::operator=(const Facts& other35) {
  facts = other35.facts;
  return *this;
}
void Facts::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Facts(";
  out << "facts=" << to_string(facts);
  out << ")";
}


Edge::~Edge() throw() {
}


void Edge::__set_s(const std::string& val) {
  this->s = val;
}

void Edge::__set_p(const std::string& val) {
  this->p = val;
}

void Edge::__set_o(const std::string& val) {
  this->o = val;
}

uint32_t Edge::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_s = false;
  bool isset_p = false;
  bool isset_o = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s);
          isset_s = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->p);
          isset_p = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->o);
          isset_o = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_s)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_p)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_o)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Edge::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Edge");

  xfer += oprot->writeFieldBegin("s", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->s);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("p", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->p);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("o", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->o);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Edge &a, Edge &b) {
  using ::std::swap;
  swap(a.s, b.s);
  swap(a.p, b.p);
  swap(a.o, b.o);
}

Edge::Edge(const Edge& other36) {
  s = other36.s;
  p = other36.p;
  o = other36.o;
}
Edge& Edge::operator=(const Edge& other37) {
  s = other37.s;
  p = other37.p;
  o = other37.o;
  return *this;
}
void Edge::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Edge(";
  out << "s=" << to_string(s);
  out << ", " << "p=" << to_string(p);
  out << ", " << "o=" << to_string(o);
  out << ")";
}


CommonInfo::~CommonInfo() throw() {
}


void CommonInfo::__set_t(const ReturnedCommonTypes& val) {
  this->t = val;
}

void CommonInfo::__set_f(const ReturnedCommonFacts& val) {
  this->f = val;
}

void CommonInfo::__set_p(const ReturnedCommonPattern& val) {
  this->p = val;
}

uint32_t CommonInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_t = false;
  bool isset_f = false;
  bool isset_p = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->t.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->t.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += this->t[_i42].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_t = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->f.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->f.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += this->f[_i47].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->p.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->p.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += this->p[_i52].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_p = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_t)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_f)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_p)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CommonInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommonInfo");

  xfer += oprot->writeFieldBegin("t", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->t.size()));
    std::vector<Types> ::const_iterator _iter53;
    for (_iter53 = this->t.begin(); _iter53 != this->t.end(); ++_iter53)
    {
      xfer += (*_iter53).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->f.size()));
    std::vector<Facts> ::const_iterator _iter54;
    for (_iter54 = this->f.begin(); _iter54 != this->f.end(); ++_iter54)
    {
      xfer += (*_iter54).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("p", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->p.size()));
    std::vector<Edge> ::const_iterator _iter55;
    for (_iter55 = this->p.begin(); _iter55 != this->p.end(); ++_iter55)
    {
      xfer += (*_iter55).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommonInfo &a, CommonInfo &b) {
  using ::std::swap;
  swap(a.t, b.t);
  swap(a.f, b.f);
  swap(a.p, b.p);
}

CommonInfo::CommonInfo(const CommonInfo& other56) {
  t = other56.t;
  f = other56.f;
  p = other56.p;
}
CommonInfo& CommonInfo::operator=(const CommonInfo& other57) {
  t = other57.t;
  f = other57.f;
  p = other57.p;
  return *this;
}
void CommonInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommonInfo(";
  out << "t=" << to_string(t);
  out << ", " << "f=" << to_string(f);
  out << ", " << "p=" << to_string(p);
  out << ")";
}


Row::~Row() throw() {
}


void Row::__set_row(const std::vector<std::string> & val) {
  this->row = val;
}

uint32_t Row::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->row.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += iprot->readString(this->row[_i62]);
            }
            xfer += iprot->readListEnd();
          }
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Row::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Row");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->row.size()));
    std::vector<std::string> ::const_iterator _iter63;
    for (_iter63 = this->row.begin(); _iter63 != this->row.end(); ++_iter63)
    {
      xfer += oprot->writeString((*_iter63));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Row &a, Row &b) {
  using ::std::swap;
  swap(a.row, b.row);
}

Row::Row(const Row& other64) {
  row = other64.row;
}
Row& Row::operator=(const Row& other65) {
  row = other65.row;
  return *this;
}
void Row::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Row(";
  out << "row=" << to_string(row);
  out << ")";
}


SparqlAndResult::~SparqlAndResult() throw() {
}


void SparqlAndResult::__set_sparql(const std::string& val) {
  this->sparql = val;
}

void SparqlAndResult::__set_result(const std::vector<Row> & val) {
  this->result = val;
}

uint32_t SparqlAndResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sparql = false;
  bool isset_result = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sparql);
          isset_sparql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _etype69;
            xfer += iprot->readListBegin(_etype69, _size66);
            this->result.resize(_size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              xfer += this->result[_i70].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sparql)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SparqlAndResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SparqlAndResult");

  xfer += oprot->writeFieldBegin("sparql", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sparql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->result.size()));
    std::vector<Row> ::const_iterator _iter71;
    for (_iter71 = this->result.begin(); _iter71 != this->result.end(); ++_iter71)
    {
      xfer += (*_iter71).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SparqlAndResult &a, SparqlAndResult &b) {
  using ::std::swap;
  swap(a.sparql, b.sparql);
  swap(a.result, b.result);
}

SparqlAndResult::SparqlAndResult(const SparqlAndResult& other72) {
  sparql = other72.sparql;
  result = other72.result;
}
SparqlAndResult& SparqlAndResult::operator=(const SparqlAndResult& other73) {
  sparql = other73.sparql;
  result = other73.result;
  return *this;
}
void SparqlAndResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SparqlAndResult(";
  out << "sparql=" << to_string(sparql);
  out << ", " << "result=" << to_string(result);
  out << ")";
}


Keywords::~Keywords() throw() {
}


void Keywords::__set_keywords(const std::vector<std::string> & val) {
  this->keywords = val;
}

uint32_t Keywords::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_keywords = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->keywords.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            xfer += iprot->readListBegin(_etype77, _size74);
            this->keywords.resize(_size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              xfer += iprot->readString(this->keywords[_i78]);
            }
            xfer += iprot->readListEnd();
          }
          isset_keywords = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_keywords)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Keywords::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Keywords");

  xfer += oprot->writeFieldBegin("keywords", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->keywords.size()));
    std::vector<std::string> ::const_iterator _iter79;
    for (_iter79 = this->keywords.begin(); _iter79 != this->keywords.end(); ++_iter79)
    {
      xfer += oprot->writeString((*_iter79));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Keywords &a, Keywords &b) {
  using ::std::swap;
  swap(a.keywords, b.keywords);
}

Keywords::Keywords(const Keywords& other80) {
  keywords = other80.keywords;
}
Keywords& Keywords::operator=(const Keywords& other81) {
  keywords = other81.keywords;
  return *this;
}
void Keywords::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Keywords(";
  out << "keywords=" << to_string(keywords);
  out << ")";
}


NegCommonInfo::~NegCommonInfo() throw() {
}


void NegCommonInfo::__set_hasProperty(const bool val) {
  this->hasProperty = val;
}

void NegCommonInfo::__set_t(const ReturnedCommonTypes& val) {
  this->t = val;
}

void NegCommonInfo::__set_f(const ReturnedCommonFacts& val) {
  this->f = val;
}

void NegCommonInfo::__set_hasKeywords(const bool val) {
  this->hasKeywords = val;
}

void NegCommonInfo::__set_k(const ReturnedCommonKeywords& val) {
  this->k = val;
}

uint32_t NegCommonInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hasProperty = false;
  bool isset_t = false;
  bool isset_f = false;
  bool isset_hasKeywords = false;
  bool isset_k = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasProperty);
          isset_hasProperty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->t.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _etype85;
            xfer += iprot->readListBegin(_etype85, _size82);
            this->t.resize(_size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              xfer += this->t[_i86].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_t = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->f.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            this->f.resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              xfer += this->f[_i91].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasKeywords);
          isset_hasKeywords = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _etype95;
            xfer += iprot->readListBegin(_etype95, _size92);
            this->k.resize(_size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              xfer += this->k[_i96].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hasProperty)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_t)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_f)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasKeywords)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_k)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NegCommonInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NegCommonInfo");

  xfer += oprot->writeFieldBegin("hasProperty", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->hasProperty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("t", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->t.size()));
    std::vector<Types> ::const_iterator _iter97;
    for (_iter97 = this->t.begin(); _iter97 != this->t.end(); ++_iter97)
    {
      xfer += (*_iter97).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->f.size()));
    std::vector<Facts> ::const_iterator _iter98;
    for (_iter98 = this->f.begin(); _iter98 != this->f.end(); ++_iter98)
    {
      xfer += (*_iter98).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasKeywords", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->hasKeywords);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->k.size()));
    std::vector<Keywords> ::const_iterator _iter99;
    for (_iter99 = this->k.begin(); _iter99 != this->k.end(); ++_iter99)
    {
      xfer += (*_iter99).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NegCommonInfo &a, NegCommonInfo &b) {
  using ::std::swap;
  swap(a.hasProperty, b.hasProperty);
  swap(a.t, b.t);
  swap(a.f, b.f);
  swap(a.hasKeywords, b.hasKeywords);
  swap(a.k, b.k);
}

NegCommonInfo::NegCommonInfo(const NegCommonInfo& other100) {
  hasProperty = other100.hasProperty;
  t = other100.t;
  f = other100.f;
  hasKeywords = other100.hasKeywords;
  k = other100.k;
}
NegCommonInfo& NegCommonInfo::operator=(const NegCommonInfo& other101) {
  hasProperty = other101.hasProperty;
  t = other101.t;
  f = other101.f;
  hasKeywords = other101.hasKeywords;
  k = other101.k;
  return *this;
}
void NegCommonInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NegCommonInfo(";
  out << "hasProperty=" << to_string(hasProperty);
  out << ", " << "t=" << to_string(t);
  out << ", " << "f=" << to_string(f);
  out << ", " << "hasKeywords=" << to_string(hasKeywords);
  out << ", " << "k=" << to_string(k);
  out << ")";
}

} // namespace
