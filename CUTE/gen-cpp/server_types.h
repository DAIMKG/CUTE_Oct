/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef server_TYPES_H
#define server_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace demo {

typedef std::vector<class Types>  ReturnedCommonTypes;

typedef std::vector<class Facts>  ReturnedCommonFacts;

typedef std::vector<class Edge>  ReturnedCommonPattern;

typedef std::vector<class Keywords>  ReturnedCommonKeywords;

class Candidate;

class OneRowCandidate;

class OneType;

class Types;

class OneFact;

class Facts;

class Edge;

class CommonInfo;

class Row;

class SparqlAndResult;

class Keywords;

class NegCommonInfo;


class Candidate : public virtual ::apache::thrift::TBase {
 public:

  Candidate(const Candidate&);
  Candidate& operator=(const Candidate&);
  Candidate() {
  }

  virtual ~Candidate() throw();
  std::vector<std::string>  c;

  void __set_c(const std::vector<std::string> & val);

  bool operator == (const Candidate & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Candidate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Candidate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Candidate &a, Candidate &b);

inline std::ostream& operator<<(std::ostream& out, const Candidate& obj)
{
  obj.printTo(out);
  return out;
}


class OneRowCandidate : public virtual ::apache::thrift::TBase {
 public:

  OneRowCandidate(const OneRowCandidate&);
  OneRowCandidate& operator=(const OneRowCandidate&);
  OneRowCandidate() {
  }

  virtual ~OneRowCandidate() throw();
  std::vector<Candidate>  row;

  void __set_row(const std::vector<Candidate> & val);

  bool operator == (const OneRowCandidate & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const OneRowCandidate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OneRowCandidate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OneRowCandidate &a, OneRowCandidate &b);

inline std::ostream& operator<<(std::ostream& out, const OneRowCandidate& obj)
{
  obj.printTo(out);
  return out;
}


class OneType : public virtual ::apache::thrift::TBase {
 public:

  OneType(const OneType&);
  OneType& operator=(const OneType&);
  OneType() : typeName() {
  }

  virtual ~OneType() throw();
  std::string typeName;

  void __set_typeName(const std::string& val);

  bool operator == (const OneType & rhs) const
  {
    if (!(typeName == rhs.typeName))
      return false;
    return true;
  }
  bool operator != (const OneType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OneType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OneType &a, OneType &b);

inline std::ostream& operator<<(std::ostream& out, const OneType& obj)
{
  obj.printTo(out);
  return out;
}


class Types : public virtual ::apache::thrift::TBase {
 public:

  Types(const Types&);
  Types& operator=(const Types&);
  Types() {
  }

  virtual ~Types() throw();
  std::vector<OneType>  types;

  void __set_types(const std::vector<OneType> & val);

  bool operator == (const Types & rhs) const
  {
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const Types &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Types & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Types &a, Types &b);

inline std::ostream& operator<<(std::ostream& out, const Types& obj)
{
  obj.printTo(out);
  return out;
}


class OneFact : public virtual ::apache::thrift::TBase {
 public:

  OneFact(const OneFact&);
  OneFact& operator=(const OneFact&);
  OneFact() : direction(0), P(), SorO() {
  }

  virtual ~OneFact() throw();
  bool direction;
  std::string P;
  std::string SorO;

  void __set_direction(const bool val);

  void __set_P(const std::string& val);

  void __set_SorO(const std::string& val);

  bool operator == (const OneFact & rhs) const
  {
    if (!(direction == rhs.direction))
      return false;
    if (!(P == rhs.P))
      return false;
    if (!(SorO == rhs.SorO))
      return false;
    return true;
  }
  bool operator != (const OneFact &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OneFact & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OneFact &a, OneFact &b);

inline std::ostream& operator<<(std::ostream& out, const OneFact& obj)
{
  obj.printTo(out);
  return out;
}


class Facts : public virtual ::apache::thrift::TBase {
 public:

  Facts(const Facts&);
  Facts& operator=(const Facts&);
  Facts() {
  }

  virtual ~Facts() throw();
  std::vector<OneFact>  facts;

  void __set_facts(const std::vector<OneFact> & val);

  bool operator == (const Facts & rhs) const
  {
    if (!(facts == rhs.facts))
      return false;
    return true;
  }
  bool operator != (const Facts &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Facts & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Facts &a, Facts &b);

inline std::ostream& operator<<(std::ostream& out, const Facts& obj)
{
  obj.printTo(out);
  return out;
}


class Edge : public virtual ::apache::thrift::TBase {
 public:

  Edge(const Edge&);
  Edge& operator=(const Edge&);
  Edge() : s(), p(), o() {
  }

  virtual ~Edge() throw();
  std::string s;
  std::string p;
  std::string o;

  void __set_s(const std::string& val);

  void __set_p(const std::string& val);

  void __set_o(const std::string& val);

  bool operator == (const Edge & rhs) const
  {
    if (!(s == rhs.s))
      return false;
    if (!(p == rhs.p))
      return false;
    if (!(o == rhs.o))
      return false;
    return true;
  }
  bool operator != (const Edge &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Edge & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Edge &a, Edge &b);

inline std::ostream& operator<<(std::ostream& out, const Edge& obj)
{
  obj.printTo(out);
  return out;
}


class CommonInfo : public virtual ::apache::thrift::TBase {
 public:

  CommonInfo(const CommonInfo&);
  CommonInfo& operator=(const CommonInfo&);
  CommonInfo() {
  }

  virtual ~CommonInfo() throw();
  ReturnedCommonTypes t;
  ReturnedCommonFacts f;
  ReturnedCommonPattern p;

  void __set_t(const ReturnedCommonTypes& val);

  void __set_f(const ReturnedCommonFacts& val);

  void __set_p(const ReturnedCommonPattern& val);

  bool operator == (const CommonInfo & rhs) const
  {
    if (!(t == rhs.t))
      return false;
    if (!(f == rhs.f))
      return false;
    if (!(p == rhs.p))
      return false;
    return true;
  }
  bool operator != (const CommonInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CommonInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CommonInfo &a, CommonInfo &b);

inline std::ostream& operator<<(std::ostream& out, const CommonInfo& obj)
{
  obj.printTo(out);
  return out;
}


class Row : public virtual ::apache::thrift::TBase {
 public:

  Row(const Row&);
  Row& operator=(const Row&);
  Row() {
  }

  virtual ~Row() throw();
  std::vector<std::string>  row;

  void __set_row(const std::vector<std::string> & val);

  bool operator == (const Row & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const Row &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Row & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Row &a, Row &b);

inline std::ostream& operator<<(std::ostream& out, const Row& obj)
{
  obj.printTo(out);
  return out;
}


class SparqlAndResult : public virtual ::apache::thrift::TBase {
 public:

  SparqlAndResult(const SparqlAndResult&);
  SparqlAndResult& operator=(const SparqlAndResult&);
  SparqlAndResult() : sparql() {
  }

  virtual ~SparqlAndResult() throw();
  std::string sparql;
  std::vector<Row>  result;

  void __set_sparql(const std::string& val);

  void __set_result(const std::vector<Row> & val);

  bool operator == (const SparqlAndResult & rhs) const
  {
    if (!(sparql == rhs.sparql))
      return false;
    if (!(result == rhs.result))
      return false;
    return true;
  }
  bool operator != (const SparqlAndResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SparqlAndResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SparqlAndResult &a, SparqlAndResult &b);

inline std::ostream& operator<<(std::ostream& out, const SparqlAndResult& obj)
{
  obj.printTo(out);
  return out;
}


class Keywords : public virtual ::apache::thrift::TBase {
 public:

  Keywords(const Keywords&);
  Keywords& operator=(const Keywords&);
  Keywords() {
  }

  virtual ~Keywords() throw();
  std::vector<std::string>  keywords;

  void __set_keywords(const std::vector<std::string> & val);

  bool operator == (const Keywords & rhs) const
  {
    if (!(keywords == rhs.keywords))
      return false;
    return true;
  }
  bool operator != (const Keywords &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Keywords & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Keywords &a, Keywords &b);

inline std::ostream& operator<<(std::ostream& out, const Keywords& obj)
{
  obj.printTo(out);
  return out;
}


class NegCommonInfo : public virtual ::apache::thrift::TBase {
 public:

  NegCommonInfo(const NegCommonInfo&);
  NegCommonInfo& operator=(const NegCommonInfo&);
  NegCommonInfo() : hasProperty(0), hasKeywords(0) {
  }

  virtual ~NegCommonInfo() throw();
  bool hasProperty;
  ReturnedCommonTypes t;
  ReturnedCommonFacts f;
  bool hasKeywords;
  ReturnedCommonKeywords k;

  void __set_hasProperty(const bool val);

  void __set_t(const ReturnedCommonTypes& val);

  void __set_f(const ReturnedCommonFacts& val);

  void __set_hasKeywords(const bool val);

  void __set_k(const ReturnedCommonKeywords& val);

  bool operator == (const NegCommonInfo & rhs) const
  {
    if (!(hasProperty == rhs.hasProperty))
      return false;
    if (!(t == rhs.t))
      return false;
    if (!(f == rhs.f))
      return false;
    if (!(hasKeywords == rhs.hasKeywords))
      return false;
    if (!(k == rhs.k))
      return false;
    return true;
  }
  bool operator != (const NegCommonInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NegCommonInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NegCommonInfo &a, NegCommonInfo &b);

inline std::ostream& operator<<(std::ostream& out, const NegCommonInfo& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
